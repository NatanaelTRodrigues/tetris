<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Tetris — Fix cursor edge + scroll rotate</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { height:100%; margin:0; padding:0; overflow:hidden; }
    :root{
      --page-bg:#071228;
      --panel-bg:#d7e1ef;
      --canvas-bg:#f6f9fe;
      --grid-line:rgba(0,0,0,0.22);
      --cell-stroke:rgba(0,0,0,0.09);
      --hud-text:#0b1620;
      --button-bg:#e6edf7;
    }
    body{
      background:var(--page-bg); color:#fff; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;
      display:flex; align-items:center; justify-content:center; gap:18px; height:100vh;
    }
    .wrap{ display:flex; gap:18px; align-items:stretch; width:100%; max-width:1200px; padding:18px; box-sizing:border-box; }
    .left{ flex:1 1 auto; display:flex; flex-direction:column; align-items:center; gap:12px; }
    canvas#tetris{
      border-radius:8px; background:var(--canvas-bg); box-shadow:0 6px 18px rgba(0,0,0,0.35);
      width:360px; height:720px; image-rendering:pixelated; display:block; border:2px solid rgba(255,255,255,0.04);
    }
    .controls-row{ display:flex; gap:10px; width:100%; justify-content:center; flex-wrap:wrap; }
    button{ background:var(--button-bg); color:var(--hud-text); border:1px solid rgba(11,17,24,0.06);
      padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:600; min-width:72px; }
    .touch-controls{ display:flex; gap:8px; margin-top:6px; }
    .hud{
      width:320px; background:linear-gradient(#eaf1fb,#d7e6f7); border-radius:10px; padding:12px; box-shadow:0 10px 30px rgba(0,0,0,0.3);
      display:flex; flex-direction:column; gap:10px; box-sizing:border-box; color:var(--hud-text);
    }
    .info-row{ display:flex; justify-content:space-between; gap:8px; align-items:center; }
    .info-row .label{ font-size:12px; color:#6b7b8c; }
    .info-row .value{ font-size:20px; font-weight:800; color:var(--hud-text); }
    .mini-canvas{ width:120px; height:120px; border-radius:8px; background:var(--canvas-bg); border:1px solid rgba(11,17,24,0.04); image-rendering:pixelated;}
    .ranking{ max-height:200px; overflow:auto; background:transparent; padding:6px; border-radius:6px; font-size:14px; color:var(--hud-text); }
    .overlay{ position:absolute; display:flex; align-items:center; justify-content:center; inset:0; background:rgba(0,0,0,0.45); color:#fff; font-size:28px; border-radius:8px; pointer-events:none; }
    .footer-hint{ font-size:13px; color:#6b7b8c; text-align:center; }
    @media (max-width:880px){ .wrap{ flex-direction:column; align-items:center; padding:12px } .hud{ width:100% } }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="left">
      <div style="position:relative; width:100%; display:flex; justify-content:center;">
        <canvas id="tetris" width="300" height="600"></canvas>
        <div id="pauseOverlay" class="overlay" style="display:none; pointer-events:none;"><div id="overlayText"></div></div>
      </div>

      <div class="controls-row">
        <button id="btnStart" class="small">Iniciar</button>
        <button id="btnPause" class="small">Pausar</button>
        <button id="btnRestart" class="small">Reiniciar</button>
        <button id="btnHold" class="small">Hold (C / Botão Direito)</button>
      </div>

      <div class="touch-controls" style="justify-content:center; width:100%;">
        <button id="btnLeft">⬅</button>
        <button id="btnRotate">⤾</button>
        <button id="btnRight">➡</button>
        <button id="btnDrop">⬇</button>
      </div>

      <div class="footer-hint">← → mover / ↑ girar / ↓ queda rápida / Espaço pausar / C ou botão direito = Hold / Clique esquerdo = Hard Drop / Scroll = girar</div>
    </div>

    <div class="hud">
      <div class="info-row">
        <div><div class="label">Pontuação</div><div id="score" class="value">0</div></div>
        <div><div class="label">Nível</div><div id="level" class="value">1</div></div>
        <div><div class="label">Linhas</div><div id="lines" class="value">0</div></div>
      </div>

      <div style="display:flex; gap:12px; align-items:center;">
        <div style="flex:1"><div class="label">Hold</div><canvas id="holdCanvas" class="mini-canvas" width="120" height="120"></canvas></div>
        <div style="flex:1"><div class="label">Próxima</div><canvas id="nextCanvas" class="mini-canvas" width="120" height="120"></canvas></div>
      </div>

      <div><div class="label">Ranking Local</div><div id="ranking" class="ranking"></div></div>
    </div>
  </div>

<script>
/* Tetris atualizado: collide corrigido para limites + cursor-edge fix + wheel rotate */
/* --- elementos e configuração --- */
const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
ctx.scale(30,30);

const nextCanvas = document.getElementById('nextCanvas');
const nextCtx = nextCanvas.getContext('2d');
const holdCanvas = document.getElementById('holdCanvas');
const holdCtx = holdCanvas.getContext('2d');

const scoreEl = document.getElementById('score');
const levelEl = document.getElementById('level');
const linesEl = document.getElementById('lines');
const rankingEl = document.getElementById('ranking');

const btnStart = document.getElementById('btnStart');
const btnPause = document.getElementById('btnPause');
const btnRestart = document.getElementById('btnRestart');
const btnLeft = document.getElementById('btnLeft');
const btnRight = document.getElementById('btnRight');
const btnRotate = document.getElementById('btnRotate');
const btnDrop = document.getElementById('btnDrop');
const btnHold = document.getElementById('btnHold');
const pauseOverlay = document.getElementById('pauseOverlay');
const overlayText = document.getElementById('overlayText');

const COLS = 10, ROWS = 20;

const colors = [ null, '#00bcd4','#1565c0','#ff8f00','#ffd54f','#4caf50','#9c27b0','#f44336' ];
const shapes = {
  'I': [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
  'J': [[2,0,0],[2,2,2],[0,0,0]],
  'L': [[0,0,3],[3,3,3],[0,0,0]],
  'O': [[4,4],[4,4]],
  'S': [[0,5,5],[5,5,0],[0,0,0]],
  'T': [[0,6,0],[6,6,6],[0,0,0]],
  'Z': [[7,7,0],[0,7,7],[0,0,0]]
};

function createMatrix(w,h){ const m=[]; while(h--) m.push(new Array(w).fill(0)); return m; }

/* desenho grade */
function drawGrid(){
  ctx.save();
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg') || '#f6f9fe';
  ctx.fillRect(0,0,COLS,ROWS);
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-line') || 'rgba(0,0,0,0.22)';
  ctx.lineWidth = 0.02;
  for(let x=0;x<=COLS;++x){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,ROWS); ctx.stroke(); }
  for(let y=0;y<=ROWS;++y){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(COLS,y); ctx.stroke(); }
  ctx.restore();
}

function drawMatrix(matrix, offset){
  matrix.forEach((row,y) => row.forEach((value,x) => {
    if(value !== 0){
      ctx.fillStyle = colors[value];
      ctx.fillRect(x+offset.x, y+offset.y, 1,1);
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--cell-stroke') || 'rgba(0,0,0,0.09)';
      ctx.lineWidth = 0.02;
      ctx.strokeRect(x+offset.x+0.02, y+offset.y+0.02, 0.96, 0.96);
    }
  }));
}

function drawGhost(matrix,pos){
  const ghost = {x:pos.x, y:pos.y};
  while(!collide(arena,{matrix,pos:ghost})){ ghost.y++; }
  ghost.y--;
  ctx.globalAlpha = 0.22;
  matrix.forEach((row,y)=> row.forEach((value,x)=> { if(value!==0){ ctx.fillStyle = colors[value]; ctx.fillRect(x+ghost.x, y+ghost.y,1,1); }}));
  ctx.globalAlpha = 1;
}

/* merge / rotate (collide substituted below) */
function merge(arena, player){
  player.matrix.forEach((row,y)=> row.forEach((value,x)=>{ if(value!==0) arena[y+player.pos.y][x+player.pos.x]=value; }));
}
function rotate(matrix, dir){
  for(let y=0;y<matrix.length;++y) for(let x=0;x<matrix.length && x<y;++x) [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
  if(dir>0) matrix.forEach(row=>row.reverse()); else matrix.reverse();
}

/* ---------- Nova função collide (corrigida para limites) ---------- */
function collide(arena, player){
  const [m, o] = [player.matrix, player.pos];
  for (let y = 0; y < m.length; ++y) {
    for (let x = 0; x < m[y].length; ++x) {
      if (m[y][x] !== 0) {
        const ax = x + o.x;
        const ay = y + o.y;
        // Fora das bordas horizontais ou abaixo do fundo -> colisão
        if (ax < 0 || ax >= COLS || ay >= ROWS) {
          return true;
        }
        // Células acima do topo não contam como colisão
        if (ay < 0) continue;
        // Se célula dentro da arena e preenchida -> colisão
        if (arena[ay] && arena[ay][ax] !== 0) {
          return true;
        }
      }
    }
  }
  return false;
}

/* peças/fila/hold */
function createPiece(t){ return shapes[t].map(r=>r.slice()); }
function randomPiece(){ const pieces='TJLOSZI'; return pieces[Math.floor(Math.random()*pieces.length)]; }

let arena = createMatrix(COLS, ROWS);
let player = { pos:{x:0,y:0}, matrix:null, matrixType:null, score:0, level:1, lines:0 };
let dropCounter = 0, baseLevelInterval = 1000, lastTime = 0;
let isRunning=false, isPaused=false, gameStartTime=null;

let nextPiece = randomPiece(), holdPiece = null, holdUsed = false;

/* spawn */
function playerReset(){
  player.matrixType = nextPiece;
  player.matrix = createPiece(player.matrixType);
  player.pos.y = 0;
  player.pos.x = Math.floor((COLS - player.matrix[0].length)/2);
  nextPiece = randomPiece();
  drawNextPiece();
  holdUsed = false;
  if(collide(arena, player)){
    isRunning=false; overlayText.innerText='Game Over'; pauseOverlay.style.display='flex';
    setTimeout(()=> {
      const name = prompt('Game Over — digite seu nome para salvar no ranking:', 'Player') || 'Player';
      saveScore({name:name.trim(), score:player.score, date:new Date().toISOString()});
      loadRanking();
    }, 50);
  }
}

/* hold */
function doHold(){
  if(!isRunning || isPaused) return;
  if(holdUsed) return;
  if(!holdPiece){
    holdPiece = player.matrixType;
    player.matrixType = nextPiece;
    player.matrix = createPiece(player.matrixType);
    nextPiece = randomPiece();
  } else {
    const tmp = holdPiece;
    holdPiece = player.matrixType;
    player.matrixType = tmp;
    player.matrix = createPiece(player.matrixType);
  }
  player.pos.x = Math.floor((COLS - player.matrix[0].length)/2);
  player.pos.y = 0;
  holdUsed = true;
  drawHoldPiece(); drawNextPiece();
}

/* hardDrop */
function hardDrop(){
  if(!isRunning || isPaused) return;
  while(true){
    player.pos.y++;
    if(collide(arena, player)){
      player.pos.y--;
      merge(arena, player);
      playerReset();
      arenaSweep();
      break;
    }
  }
  dropCounter = 0;
}

/* sweep */
function arenaSweep(){
  let rowCount=0;
  outer: for(let y=arena.length-1;y>=0;--y){
    for(let x=0;x<arena[y].length;++x) if(arena[y][x]===0) continue outer;
    const row = arena.splice(y,1)[0].fill(0);
    arena.unshift(row);
    rowCount++; y++;
  }
  if(rowCount>0){
    const pointsByClear=[0,100,250,450,700];
    player.score += (pointsByClear[rowCount]||rowCount*200);
    player.lines += rowCount;
    const newLevel = Math.floor(player.lines/10)+1;
    if(newLevel > player.level){
      player.level = newLevel;
      baseLevelInterval = Math.max(100, 1000 - (player.level-1)*90);
    }
    updateScore();
  }
}

/* movimentação */
function playerDrop(){ if(!isRunning||isPaused) return; player.pos.y++; if(collide(arena,player)){ player.pos.y--; merge(arena,player); playerReset(); arenaSweep(); } dropCounter=0; }
function playerMove(dir){ if(!isRunning||isPaused) return; player.pos.x += dir; if(collide(arena,player)) player.pos.x -= dir; }
function playerRotate(dir){ if(!isRunning||isPaused) return; const pos = player.pos.x; let offset=1; rotate(player.matrix,dir); while(collide(arena,player)){ player.pos.x += offset; offset = -(offset + (offset>0?1:-1)); if(Math.abs(offset) > player.matrix[0].length){ rotate(player.matrix,-dir); player.pos.x = pos; return; } } }

/* UI next/hold */
function updateScore(){ scoreEl.textContent = player.score; levelEl.textContent = player.level; linesEl.textContent = player.lines; }
function drawNextPiece(){ nextCtx.clearRect(0,0,nextCanvas.width,nextCanvas.height); const cell=20; const matrix=createPiece(nextPiece); const w=matrix[0].length,h=matrix.length; const offsetX=Math.floor((nextCanvas.width/cell - w)/2); const offsetY=Math.floor((nextCanvas.height/cell - h)/2); for(let y=0;y<h;y++) for(let x=0;x<w;x++) if(matrix[y][x]!==0){ nextCtx.fillStyle = colors[matrix[y][x]]; nextCtx.fillRect((x+offsetX)*cell,(y+offsetY)*cell,cell-2,cell-2); } }
function drawHoldPiece(){ holdCtx.clearRect(0,0,holdCanvas.width,holdCanvas.height); const cell=20; if(!holdPiece) return; const matrix=createPiece(holdPiece); const w=matrix[0].length,h=matrix.length; const offsetX=Math.floor((holdCanvas.width/cell - w)/2); const offsetY=Math.floor((holdCanvas.height/cell - h)/2); for(let y=0;y<h;y++) for(let x=0;x<w;x++) if(matrix[y][x]!==0){ holdCtx.fillStyle = colors[matrix[y][x]]; holdCtx.fillRect((x+offsetX)*cell,(y+offsetY)*cell,cell-2,cell-2); } }

/* draw principal */
function draw(){ drawGrid(); drawMatrix(arena,{x:0,y:0}); drawGhost(player.matrix, player.pos); drawMatrix(player.matrix, player.pos); }

/* loop com aceleração por tempo + nível */
function update(time = 0){
  if(!isRunning){ lastTime = time; requestAnimationFrame(update); return; }
  const deltaTime = time - lastTime; lastTime = time;
  if(!isPaused){
    const elapsedSeconds = (performance.now() - (gameStartTime || performance.now())) / 1000;
    const timeReduction = Math.floor(elapsedSeconds / 5) * 20;
    const dynamicInterval = Math.max(100, baseLevelInterval - timeReduction);
    dropCounter += deltaTime;
    if(dropCounter > dynamicInterval) playerDrop();
  }
  draw();
  requestAnimationFrame(update);
}

/* ---------- INPUTS ---------- */
/* teclado */
document.addEventListener('keydown', e => {
  if(e.code === 'Space'){ if(isRunning) togglePause(); return; } // espaço sempre alterna
  if(!isRunning || isPaused) return;
  if(e.key === 'ArrowLeft') playerMove(-1);
  else if(e.key === 'ArrowRight') playerMove(1);
  else if(e.key === 'ArrowDown') playerDrop();
  else if(e.key === 'ArrowUp') playerRotate(1);
  else if(e.key.toLowerCase() === 'c') doHold();
});

/* botões */
btnLeft.addEventListener('pointerdown', ()=> { if(!isPaused && isRunning) playerMove(-1); });
btnRight.addEventListener('pointerdown', ()=> { if(!isPaused && isRunning) playerMove(1); });
btnRotate.addEventListener('pointerdown', ()=> { if(!isPaused && isRunning) playerRotate(1); });
btnDrop.addEventListener('pointerdown', ()=> { if(!isPaused && isRunning) playerDrop(); });
btnHold.addEventListener('click', ()=> { if(!isPaused && isRunning) doHold(); });

btnStart.addEventListener('click', ()=> startGame());
btnRestart.addEventListener('click', ()=> restartGame());
btnPause.addEventListener('click', ()=> togglePause());

/* --- CURSOR movement: improved mapping + nearest-valid search --- */
function findClosestValidX(targetX, pieceW){
  const minX = 0, maxX = COLS - pieceW;
  if(targetX < minX) targetX = minX;
  if(targetX > maxX) targetX = maxX;
  if(!collide(arena, {matrix: player.matrix, pos:{x: targetX, y: player.pos.y}})) return targetX;
  // procurar offsets alternando esquerda/direita até a distância máxima
  const maxRange = Math.max(targetX - minX, maxX - targetX);
  for(let offset = 1; offset <= maxRange; offset++){
    const leftX = targetX - offset;
    const rightX = targetX + offset;
    if(leftX >= minX && !collide(arena, {matrix: player.matrix, pos:{x:leftX, y:player.pos.y}})) return leftX;
    if(rightX <= maxX && !collide(arena, {matrix: player.matrix, pos:{x:rightX, y:player.pos.y}})) return rightX;
  }
  return null;
}

canvas.addEventListener('pointermove', (ev) => {
  if(!isRunning || isPaused) return;
  const rect = canvas.getBoundingClientRect();
  const relative = (ev.clientX - rect.left) / rect.width * COLS;
  const pieceW = player.matrix[0].length;
  let targetCol = Math.round(relative);
  let targetX = targetCol - Math.floor(pieceW / 2);
  const closest = findClosestValidX(targetX, pieceW);
  if(closest !== null){
    player.pos.x = closest;
  }
});

/* pointerdown: left = hardDrop, other gestures for touch */
let touchStartX = null, touchStartY = null;
canvas.addEventListener('pointerdown', (ev) => {
  if(!isRunning || isPaused) return;
  if(ev.pointerType === 'mouse' && ev.button === 0){
    hardDrop();
    ev.preventDefault();
    return;
  }
  touchStartX = ev.clientX; touchStartY = ev.clientY;
});

/* pointerup: gestures */
canvas.addEventListener('pointerup', (ev) => {
  if(!isRunning || isPaused) { touchStartX = null; touchStartY = null; return; }
  if(touchStartX === null) return;
  const dx = ev.clientX - touchStartX;
  const dy = ev.clientY - touchStartY;
  if(Math.abs(dx) > Math.abs(dy)){
    if(dx > 20) playerMove(1); else if(dx < -20) playerMove(-1);
  } else {
    if(dy > 20) playerDrop(); else if(Math.abs(dy) < 10) playerRotate(1);
  }
  touchStartX = null; touchStartY = null;
});

/* right click => hold (previne menu) */
canvas.addEventListener('contextmenu', (ev) => {
  ev.preventDefault();
  if(!isRunning || isPaused) return;
  doHold();
});

/* WHEEL = rotate (scroll) — bloqueado quando pausado */
canvas.addEventListener('wheel', (ev) => {
  ev.preventDefault();
  if(!isRunning || isPaused) return;
  const dir = ev.deltaY > 0 ? 1 : -1;
  playerRotate(dir);
}, {passive:false});

/* ranking local */
function loadRanking(){
  const raw = localStorage.getItem('tetris_ranking_v1'); let list=[];
  if(raw){ try{ list = JSON.parse(raw); } catch(e){ list = []; } }
  list.sort((a,b)=> b.score - a.score);
  rankingEl.innerHTML='';
  if(list.length === 0) rankingEl.innerHTML = '<div style="opacity:0.6">Sem scores ainda.</div>';
  list.slice(0,10).forEach((item,i)=> {
    const el = document.createElement('div'); el.style.display='flex'; el.style.justifyContent='space-between'; el.style.padding='6px 4px';
    el.style.borderBottom='1px solid rgba(11,17,24,0.03)';
    el.innerHTML = `<div style="font-weight:700">${i+1}. ${escapeHtml(item.name)}</div><div style="opacity:0.85">${item.score}</div>`;
    rankingEl.appendChild(el);
  });
}
function saveScore(obj){
  const raw = localStorage.getItem('tetris_ranking_v1'); let list=[];
  if(raw){ try{ list = JSON.parse(raw); } catch(e){ list = []; } }
  list.push(obj); localStorage.setItem('tetris_ranking_v1', JSON.stringify(list));
}
function escapeHtml(s){ return String(s).replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

/* Start / Restart / Pause */
function startGame(){
  arena = createMatrix(COLS, ROWS);
  player = { pos:{x:0,y:0}, matrix:null, matrixType:null, score:0, level:1, lines:0 };
  baseLevelInterval = 1000;
  nextPiece = randomPiece(); holdPiece = null; holdUsed = false;
  playerReset(); drawHoldPiece(); drawNextPiece(); updateScore();
  isRunning = true; isPaused = false; pauseOverlay.style.display='none'; overlayText.innerText='';
  gameStartTime = performance.now();
}
function restartGame(){ if(!confirm('Reiniciar o jogo?')) return; startGame(); }
function togglePause(){ if(!isRunning) return; isPaused = !isPaused; pauseOverlay.style.display = isPaused ? 'flex' : 'none'; overlayText.innerText = isPaused ? 'Pausado' : ''; }

/* fit canvas to viewport */
function fitCanvasToViewport(){
  const maxHeight = window.innerHeight - 160;
  let desiredHeight = Math.max(300, Math.min(1000, maxHeight));
  let desiredWidth = Math.floor(desiredHeight / 2);
  const maxWidth = Math.min(window.innerWidth * 0.6, 720);
  if(desiredWidth > maxWidth){ desiredWidth = Math.floor(maxWidth); desiredHeight = desiredWidth * 2; }
  canvas.style.width = desiredWidth + 'px'; canvas.style.height = desiredHeight + 'px';
}
window.addEventListener('resize', fitCanvasToViewport);
fitCanvasToViewport();

/* inicialização */
loadRanking(); drawNextPiece(); drawHoldPiece(); update();

</script>
</body>
</html>
